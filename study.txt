
[필기장]

*강조강조강조★★★
- Java에서의 대입은 항상 변수에 들어 있는 값을 복사해서 전달한다.
   ex. ClassStart4.java 파일 코드에서 student1 객체는 하나 뿐이고 접근할 수 있는 주소값을 가진 변수가 2개(student1, students[0])인 것이다.


+입문 강의 필기 부분
+----------------------------------------------------------------------------------------------------------------------------------------------+
*기본
- java는 대소문자를 구분한다.
- main 메서드가 프로그램의 시작점이다.
- java는 한 문장이 끝날 때마다 세미콜론(;)을 입력해서 구분을 해주어야 한다.
- error를 확인하고 나면 꼭 error 부분을 주석처리 해야한다. 하지않으면, 다른 예제를 실행할 때도 해당 부분의 error가 발생할 수 있다. (모든 파일을 컴파일하기 때문)
- 형변환 = 캐스팅(Casting)


*단축입력
- psvm
 ┗ " public static void main(String[] args) {} " 자동으로 입력된다.

- sout
 ┗ " System.out.println(); " 자동으로 입력된다.

- iter
 ┗ 리스트에 대한 향상된 for문이 자동으로 입력된다.
    for (int number : numbers) {}


*단축키
- 코드 실행
 ┗ Ctrl + Shift + F10

- 중복 부분 선택 (VSCode에서의 Ctrl + D)
 ┗ Alt + J
- 중복 부분 전체 선택
 ┗ Shift + F6

- 한 줄 복사+붙여넣기 (Ctrl + C , Ctrl + V 보다 간편)
 ┗ Ctrl + D

- 한 줄 이동 (VSCode에서의 Alt + 방향키)
 ┗ Alt + Shift + 방향키

- 마우스 드래그한 것처럼 선택 영역 확장
 ┗ Ctrl + W / Ctrl + Shift + W

- 코드 완성 시키기 (세미콜론(;)이 없어도 자동으로 작성된다.)
 ┗ Ctrl + Shift + Enter

- 함수의 반환 값을 담을 변수 자동 입력
 ┗ Ctrl + Alt + V
   ex) getTotalAmount(orders) 입력 후 단축키 실행 ⇒ int totalAmount = getTotalAmount(orders);   //ref>ex>ProductOrderMain2.java 파일 참고

- 필요한 파라미터 보기
 ┗ 파라미터를 넣는 () 괄호 안에 커서를 두고 Ctrl + P

- Generate
 ┗ Alt + Insert

- GitHub Commit
 ┗ Ctrl + K
- GitHub Push
 ┗ Ctrl + Shift + K
 +----------------------------------------------------------------------------------------------------------------------------------------------+


*Class
- Class 내부 변수들 : 멤버변수(Member Variable)라고도 하고, 필드(Field)라고도 한다.

- 인스턴스, 객체 : 특정 Class로부터 생성된 객체를 의미한다.
   ex. Student student1 = new Student();    // 참조값(주소)을 반환해줘서 변수에 대입된다.
   ↳ 객체 vs 인스턴스
     : 인스턴스는 객체가 어떤 클래스에 속해 있는지 강조할 때 사용한다.
       "student1 객체는 Student 클래스의 인스턴스다."
       ⇒ 둘 다 Class에서 나온 실체라는 의미에서 비슷하게 사용되지만, 용어상 인스턴스는 관계에 초점을 맞춘 단어이다.


*기본형과 참조형
- 기본형은 독립적이다. (ref>VarChange1.java 참고)
- 참조형은 참조하는 값이 변경되면 같이 변경된다. (ref>VarChange2.java 참고)
⇒ 변수에 들어있는 값을 복사해서 사용한다는 점이 핵심이다.
  기본형은 변수에 숫자 값이 들어있기 때문에 독립적인거고, 참조형은 변수에 주소 값이 들어있기 때문에 같은 주소를 바라보게되어 같이 변경되는 것이다.


*Garbage Collection(가비지 컬렉션)
- 아무도 참조하지 않는 인스턴스의 최후
- NullMain1.java 파일에서 data에 참조값을 대입했다가 다시 null로 바꾸었다.
  더 이상 그 참조값은 참조되지 않아서 메모리 용량만 차지하게 된다.
- C언어와 같은 과거 프로그래밍 언어는 개발자가 직접 명령어를 사용해서 인스턴스를 메모리에서 제거해야 했다.
  실수로 인스턴스 제거를 누락하면 메모리에 사용하지 않는 객체가 가득해져서 메모리 오버플로우 오류가 발생하게 된다.
- Java는 자동으로 해준다.
  아무도 참조하지 않는 인스턴스가 있으면 JVM의 GC(가비지 컬렉션)가 더 이상 사용하지 않는 인스턴스라 판단하고 자동으로 메모리에서 제거해준다.


*NullPointerException
- 굉장히 자주 보게될 오류이다.
- 참조값 없이 객체를 찾아가면 나타나는 오류이다. (Null에 .(dot_객체접근)을 찍었을 때)


*절차지향프로그래밍
- 지금까지 했던게 다 절차지향이다. (class1 ~ ref 폴더)
- 실행 순서를 중요하게 생각하는 방식이다. 프로그램의 흐름을 순차적으로 따르며 처리하는 방식이다.
- 절차지향프로그래밍의 한계
  ⇒ oop1>MusicPlayerMain3.java 참고 / 객체 data가 변경되면 선언한 메서드 모두 수정이 필요하다.


*객체지향프로그래밍
- 실제 세계의 사물이나 사건을 객체로 보고, 객체들 간의 상호작용을 중심으로 프로그래밍하는 방식이다.
- oop1>MusicPlayer.java & MusicPlayerMain.java 참고 / MusicPlayer 객체를 사용하는 사람은 MusicPlayer의 코드를 몰라도 된다. 호출해서 사용하기만 하면 된다.
  ⇒ ex) 전자제품 사용할 때 어떻게 만들어졌는지 알 필요가 없다. 사용만 하면 된다.
- 캡슐화
  ⇒ 속성과 기능을 하나로 묶어서 필요한 기능을 메서드를 통해 외부에 제공하는 것
- 수정해야되는 부분은 객체 선언 부분(캡슐)만 수정하면 되고 호출해서 사용하는 부분에서는 수정할 게 없다. (절차지향프로그래밍 한계의 극복)


*this
- 객체의 "멤버변수"와 객체 내부 메서드의 "매개변수" 이름이 같으면 더 안쪽에 있는 매개변수가 우선순위이다.
- 멤버변수에 접근하려면 앞에 this. 을 붙여주면 된다. (construct>memberInit.java 참고)
  (멤버변수와 매개변수의 이름이 동일하지 않아도 멤버변수에 접근할 때에는 this. 를 붙여주는 코딩 스타일이 옛날에는 유행했었으나, 지금은 안하는 추세이기도 하고 IDE에서 색으로 구분을 해주기 때문에 권장하지 않는다.)
- 반복 문장 줄이기는 construct>MemberConstruct.java 참고


*생성자(Construct)
⇒ "생성자는 객체 생성 직후 객체를 초기화 하기 위한 특별한 메서드로 생각할 수 있다."
- 객체를 생성하고 바로 초기값을 할당해야 하는 경우가 많기 때문에 객체를 생성하자마자 즉시 필요한 기능을 수행할 수 있도록 "생성자"라는 기능을 제공한다. (construct>ConstructMain1.java 참고)
- 생성자의 이름은 클래스 이름과 같아야 한다.
- 생성자는 반환 타입이 없다. 비워두어야 한다.

*오버로딩(Overloading)
- (메서드 오버로딩처럼) 매개변수만 다르게 해서 여러 생성자를 제공할 수 있다.


*패키지(Package)
- 규칙 : 패키지의 이름과 위치는 폴터(디렉토리) 위치와 같아야 한다. (필수)
        패키지 이름은 모두 소문자를 사용한다. (관례)
        패키지 이름의 앞 부분에는 일반적으로 회사의 도메인 이름을 거꾸로 사용한다. ex. com.company.myapp (관례)
          ↳ 수 많은 외부 라이브러리가 함께 사용되면 같은 패키지에 같은 클래스 이름이 존재할 수도 있는데 이렇게 도메인 이름을 거꾸로 사용하면 해당 문제를 해결할 수 있다.


*접근제어자 종류
- private : 모든 외부 호출을 막는다.
- default(package-private) : 같은 패키지안에서 호출은 허용한다.
- protected : 같은 패키지안에서 호출은 허용한다. 패키지가 달라도 상속 관계의 호출은 허용한다.
- public : 모든 외부 호출을 허용한다.


*캡슐화
- 객체에는 속성(데이터)과 기능(메서드)이 있다.
- 캡슐화에서 가장 필수로 숨겨야 하는 것은 속성(데이터)이다.
- 객체의 데이터는 객체가 제공하는 기능은 메서드를 통해서 접근해야 한다.
- 객체의 기능 중에서 외부에서 사용하지 않고 내부에서만 사용하는 기능들은 모두 감추는 것이 좋다.
- 사용자 입장에서 꼭 필요한 기능만 외부에 노출하고 나머지 기능은 모두 내부로 숨기는 것이 좋다.
 ⇒ 정리 : 데이터는 모두 숨기고, 기능은 꼭 필요한 기능만 노출하는 것이 좋은 캡슐화이다.  (access>BankAccount.java 참고)


*자바 메모리 구조
- 메서드 영역 : 클래스 정보를 보관한다.
  ↳ 클래스 정보(실행 코드, 필드, 메서드, 생성자 코드 등)
  ↳ static 영역(static 변수)
  ↳ 런타임 상수 풀(공통으로 사용되는 상수인 리터럴)
- 스택 영역 : 실제 프로그램이 실행되는 영역이다. 메서드를 실행할 때마다 하나씩 쌓인다.
  ↳ 메서드를 호출할 때마다 하나의 스택 프레임이 쌓이고, 메서드가 종료되면 해당 스택 프레임이 제거된다.
  ↳ 각 쓰레드별로 하나의 실행 스택이 생성된다. 즉, 쓰레드 수 만큼 스택 영역이 생성된다. 지금은 쓰레드를 1개만 사용하므로 스택 영역도 하나이다.
- 힙 영역 : 객체(인스턴스)가 생성되는 영역이다. new 명령어를 사용하면 이 영역을 사용한다.
  ↳ 가비지 컬렉션(GC)이 이루어지는 주요 영역이다. 더 이상 참조되지 않는 객체는 GC에 의해 제거된다.


*자료 구조
- 스택 구조
  ↳ 후입선출(LIFO, Last In First Out)
    : 넣고 빼는 입출구가 동일하기 때문에 1 → 2 → 3 순서로 넣었다면, 3 → 2 → 1 순서로 뺄 수 있다.
- 큐 구조
  ↳ 선입선출(FIFO, First In First Out)
    : 입구, 출구가 따로 존재하기 때문에 1 → 2 → 3 순서로 넣으면, 1 → 2 → 3 순서로 뺼 수 있다.
 ⇒ 자료 구조는 각자 필요한 영역이 있다. 프로그램 실행과 메서드 호출에는 스택 구조가 적합하다.
